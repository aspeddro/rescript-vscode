#!/usr/bin/env node
// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Path = require("path");
var Js_json = require("rescript/lib/js/js_json.js");
var Belt_List = require("rescript/lib/js/belt_List.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Child_process = require("child_process");

var $$Buffer = {};

var argv = process.argv;

var args = argv.slice(2, argv.length);

var platformDir = process.arch === "arm64" ? process.platform + process.arch : process.platform;

var analysisProdPath = Path.join(Path.dirname(__dirname), "analysis_binaries", platformDir, "rescript-editor-analysis.exe");

var docHelp = "ReScript Tools\n\nOutput documentation to standard output\n\nUsage: restools doc <FILE>\n\nExample: restools doc ./path/to/EntryPointLib.res";

var help = "ReScript Tools\n\nUsage: restools [command]\n\nCommands:\n\ndoc                   Generate documentation\nreanalyze             Reanalyze\n-v, --version         Print version\n-h, --help            Print help";

function logAndExit(log, code) {
  console.log(log);
  process.exit(code);
}

var match = Belt_List.fromArray(args);

if (match) {
  var exit = 0;
  switch (match.hd) {
    case "--help" :
    case "-h" :
        exit = 1;
        break;
    case "--version" :
    case "-v" :
        exit = 2;
        break;
    case "doc" :
        var rest = match.tl;
        if (rest) {
          var filePath = rest.hd;
          var exit$1 = 0;
          switch (filePath) {
            case "--help" :
            case "-h" :
                exit$1 = 3;
                break;
            default:
              if (rest.tl) {
                logAndExit(docHelp, 1);
              } else {
                var spawn = Child_process.spawnSync(analysisProdPath, [
                      "extractDocs",
                      filePath
                    ]);
                var code = spawn.status;
                if (code !== null) {
                  if (code !== 0) {
                    logAndExit(spawn.stderr.toString(), code);
                  } else {
                    logAndExit(spawn.stdout.toString(), code);
                  }
                } else {
                  logAndExit("error: unexpected error to extract docs for " + filePath, 1);
                }
              }
          }
          if (exit$1 === 3) {
            if (rest.tl) {
              logAndExit(docHelp, 1);
            } else {
              logAndExit(docHelp, 0);
            }
          }
          
        } else {
          logAndExit(docHelp, 1);
        }
        break;
    case "reanalyze" :
        var args$1 = ["reanalyze"].concat(Belt_List.toArray(match.tl));
        var spawn$1 = Child_process.spawnSync(analysisProdPath, args$1);
        var code$1 = spawn$1.status;
        if (code$1 !== null) {
          if (code$1 !== 0) {
            logAndExit(spawn$1.stderr.toString(), code$1);
          } else {
            logAndExit(spawn$1.stdout.toString(), code$1);
          }
        } else {
          logAndExit("error: unexpected error to run reanalyze with arguments: " + args$1.join(" "), 1);
        }
        break;
    default:
      logAndExit(help, 1);
  }
  switch (exit) {
    case 1 :
        if (match.tl) {
          logAndExit(help, 1);
        } else {
          logAndExit(help, 0);
        }
        break;
    case 2 :
        if (match.tl) {
          logAndExit(help, 1);
        } else {
          var dict = Js_json.decodeObject(JSON.parse(Fs.readFileSync("./package.json")));
          if (dict !== undefined) {
            logAndExit(Caml_option.valFromOption(dict)["version"], 0);
          } else {
            logAndExit("error: failed to find version in package.json", 1);
          }
        }
        break;
    
  }
} else {
  logAndExit(help, 1);
}

exports.$$Buffer = $$Buffer;
exports.argv = argv;
exports.args = args;
exports.platformDir = platformDir;
exports.analysisProdPath = analysisProdPath;
exports.docHelp = docHelp;
exports.help = help;
exports.logAndExit = logAndExit;
/* argv Not a pure module */
